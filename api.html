<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Embree: High Performance Ray Tracing Kernels" />
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <title>Embree</title>
    <link rel="icon" type="image/png" href="images/icon192.png" sizes="192x192">
    <link rel="SHORTCUT ICON" HREF="images/icon32.ico">
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
    </style>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-64541910-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
      <div class="inner">
        <a id="forkme_banner" href="https://github.com/embree">View on GitHub</a>
        <h1 id="project_title">Embree</h1>
        <h2 id="project_tagline">High Performance Ray Tracing Kernels</h2>
      </div>

      <div id="nav">
      <div id="nbar">
        <ul>
          <li><a href="index.html">Overview</a></li>
          <li><a href="downloads.html">Downloads</a></li>
          <li id="selected"><a href="api.html">API</a></li>
          <li><a href="tutorials.html">Tutorials</a></li>
          <li><a href="gallery.html">Gallery</a></li>
          <li><a href="renderer.html">Renderer</a></li>
          <li><a href="related.html">Related Projects</a></li>
        </ul>
      </div>
      </div>

    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <div id="main_content" class="inner">
<h1 id="embree-api">Embree API</h1>
<p>The Embree API is a low level ray tracing API that supports defining and committing of geometry and performing ray queries of different types. Static and dynamic scenes are supported, that may contain triangular geometry (including linear motions for motion blur), instanced geometry, and user defined geometry. Supported ray queries are, finding the closest scene intersection along a ray, and testing a ray segment for any intersection with the scene. Single rays, as well as packets of rays in a struct of array layout can be used for packet sizes of 1, 4, 8, and 16 rays. Filter callback functions are supported, that get invoked for every intersection encountered during traversal.</p>
<p>The Embree API exists in a C++ and ISPC version. This document describes the C++ version of the API, the ISPC version is almost identical. The only differences are that the ISPC version needs some ISPC specific uniform type modifiers, and limits the ray packets to the native SIMD size the ISPC code is compiled for.</p>
<p>The user is supposed to include the <code>embree2/rtcore.h</code>, and the <code>embree2/rtcore_ray.h</code> file, but none of the other header files. If using the ISPC version of the API, the user should include <code>embree2/rtcore.isph</code> and <code>embree2/rtcore_ray.isph</code>.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree2/rtcore.h&gt;</span>
<span class="ot">#include &lt;embree2/rtcore_ray.h&gt;</span></code></pre>
<p>All API calls carry the prefix <code>rtc</code> which stands for <strong>r</strong>ay <strong>t</strong>racing <strong>c</strong>ore. Before invoking any API call, the Embree ray tracing core has to get initialized through the <code>rtcInit</code> call. Before the application exits it should call <code>rtcExit</code>. Initializing Embree again after an <code>rtcExit</code> is allowed.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcInit(NULL);
...
rtcExit();</code></pre>
<p>It is strongly recommended to have the <code>Flush to Zero</code> and <code>Denormals are Zero</code> mode of the MXCSR control and status register enabled for each thread before calling the <code>rtcIntersect</code> and <code>rtcOccluded</code> functions. Otherwise, under some circumstances special handling of denormalized floating point numbers can significantly reduce application and Embree performance. When using Embree together with the Intel® Threading Building Blocks, it is sufficient to execute the following code at the beginning of the application main thread (before the creation of the tbb::task_scheduler_init object):</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;xmmintrin.h&gt;</span>
<span class="ot">#include &lt;pmmintrin.h&gt;</span>
...
_MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);
_MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);</code></pre>
<p>Embree processes some implementation specific configuration from the following locations in the specified order:</p>
<ol style="list-style-type: decimal">
<li>configuration string passed to the <code>rtcInit</code> function</li>
<li><code>.embree2</code> file in the application folder</li>
<li><code>.embree2</code> file in the home folder</li>
</ol>
<p>This way the configuration for the application can be changed globally (either through the <code>rtcInit</code> call or through the <code>.embree2</code> file in the application folder) and each user has the option to modify the configuration to fit its needs.</p>
<p>The threads calling the API functions should have at least 4MB of stack space allocated. Also every Intel® Threading Building Blocks (TBB) worker thread needs at least 4MB of stack space (which is the default for TBB).</p>
<p>API calls that access geometries are only thread safe as long as different geometries are accessed. Accesses to one geometry have to get sequenced by the application. All other API calls are thread safe. The API calls are re-entrant, it is thus safe to trace new rays and create new geometry when intersecting a user defined object.</p>
<p>Each user thread has its own error flag in the API. If an error occurs when invoking some API function, this flag is set to an error code if it stores no previous error. The <code>rtcGetError</code> function reads and returns the currently stored error and clears the error flag again.</p>
<p>Possible error codes returned by <code>rtcGetError</code> are:</p>
<table>
<caption>Return values of <code>rtcGetError</code>.</caption>
<colgroup>
<col width="33%" />
<col width="62%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Error Code</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_NO_ERROR</td>
<td align="left">No error occurred.</td>
</tr>
<tr class="even">
<td align="left">RTC_UNKNOWN_ERROR</td>
<td align="left">An unknown error has occurred.</td>
</tr>
<tr class="odd">
<td align="left">RTC_INVALID_ARGUMENT</td>
<td align="left">An invalid argument was specified.</td>
</tr>
<tr class="even">
<td align="left">RTC_INVALID_OPERATION</td>
<td align="left">The operation is not allowed for the specified object.</td>
</tr>
<tr class="odd">
<td align="left">RTC_OUT_OF_MEMORY</td>
<td align="left">There is not enough memory left to complete the operation.</td>
</tr>
<tr class="even">
<td align="left">RTC_UNSUPPORTED_CPU</td>
<td align="left">The CPU is not supported as it does not support SSE2.</td>
</tr>
<tr class="odd">
<td align="left">RTC_CANCELLED</td>
<td align="left">The operation got cancelled by an Memory Monitor Callback or Progress Monitor Callback function.</td>
</tr>
</tbody>
</table>
<p>Using the <code>rtcSetErrorFunction</code> call, it is also possible to set a callback function that is called whenever an error occurs. The callback function gets passed the error code, as well as some string that describes the error further. Passing <code>NULL</code> to <code>rtcSetErrorFunction</code> disables the set callback function again. The previously described error flags are also set if an error callback function is present.</p>
<h2 id="scene">Scene</h2>
<p>A scene is a container for a set of geometries of potentially different types. A scene is created using the <code>rtcNewScene</code> function call, and destroyed using the <code>rtcDeleteScene</code> function call. Two types of scenes are supported, dynamic and static scenes. Different flags specify the type of scene to create and the type of ray query operations that can later be performed on the scene. The following example creates a scene that supports dynamic updates and the single ray <code>rtcIntersect</code> and <code>rtcOccluded</code> calls.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCScene scene = rtcNewScene(RTC_SCENE_DYNAMIC, RTC_INTERSECT1);
...
rtcDeleteScene(scene);</code></pre>
<p>Using the following scene flags the user can select between creating a static and dynamic scene.</p>
<table>
<caption>Dynamic type flags for <code>rtcNewScene</code>.</caption>
<thead>
<tr class="header">
<th align="left">Scene Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_SCENE_STATIC</td>
<td align="left">Scene is optimized for static geometry.</td>
</tr>
<tr class="even">
<td align="left">RTC_SCENE_DYNAMIC</td>
<td align="left">Scene is optimized for dynamic geometry.</td>
</tr>
</tbody>
</table>
<p>A dynamic scene is created by invoking <code>rtcNewScene</code> with the <code>RTC_SCENE_DYNAMIC</code> flag. Different geometries can now be created inside that scene. Geometries are enabled by default. Once the scene geometry is specified, an <code>rtcCommit</code> call will finish the scene description and trigger building of internal data structures. After the <code>rtcCommit</code> call it is safe to perform ray queries of the type specified at scene construction time. Geometries can get disabled (<code>rtcDisable</code> call), enabled again (<code>rtcEnable</code> call), and deleted (<code>rtcDeleteGeometry</code> call). Geometries can also get modified, including their vertex and index arrays. After the modification of some geometry, <code>rtcUpdate</code> or <code>rtcUpdateBuffer</code> has to get called for that geometry to specify which buffers got modified. Each modified buffer can specified separately using the <code>rtcUpdateBuffer</code> function. In contrast the <code>rtcUpdate</code> function simply tags each buffer of some geometry as modified. If geometries got enabled, disabled, deleted, or modified an <code>rtcCommit</code> call has to get invoked before performing any ray queries for the scene, otherwise the effect of the ray query is undefined. During in <code>rtcCommit</code> call modifications to the scene are not allowed.</p>
<p>A static scene is created by the <code>rtcNewScene</code> call with the <code>RTC_SCENE_STATIC</code> flag. Geometries can only get created, enabled, disabled and modified until the first <code>rtcCommit</code> call. After the <code>rtcCommit</code> call, each access to any geometry of that static scene is invalid. Geometries that got created inside a static scene can only get deleted by deleting the entire scene.</p>
<p>The modification of geometry, building of hierarchies using <code>rtcCommit</code>, and tracing of rays have always to happen separately, never at the same time.</p>
<p>The following flags can be used to tune the used acceleration structure. These flags are only hints and may be ignored by the implementation.</p>
<table>
<caption>Acceleration structure flags for <code>rtcNewScene</code>.</caption>
<colgroup>
<col width="34%" />
<col width="62%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Scene Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_SCENE_COMPACT</td>
<td align="left">Creates a compact data structure and avoids algorithms that consume much memory.</td>
</tr>
<tr class="even">
<td align="left">RTC_SCENE_COHERENT</td>
<td align="left">Optimize for coherent rays (e.g. primary rays).</td>
</tr>
<tr class="odd">
<td align="left">RTC_SCENE_INCOHERENT</td>
<td align="left">Optimize for in-coherent rays (e.g. diffuse reflection rays).</td>
</tr>
<tr class="even">
<td align="left">RTC_SCENE_HIGH_QUALITY</td>
<td align="left">Build higher quality spatial data structures.</td>
</tr>
</tbody>
</table>
<p>The following flags can be used to tune the traversal algorithm that is used by Embree. These flags are only hints and may be ignored by the implementation.</p>
<table>
<caption>Traversal algorithm flags for <code>rtcNewScene</code>.</caption>
<thead>
<tr class="header">
<th align="left">Scene Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_SCENE_ROBUST</td>
<td align="left">Avoid optimizations that reduce arithmetic accuracy.</td>
</tr>
</tbody>
</table>
<p>The second argument of the <code>rtcNewScene</code> function are algorithm flags, that allow to specify which ray queries are required by the application. Calling for a scene a ray query API function that is different to the ones specified at scene creation time is not allowed. Further, the application should only pass ray query requirements that are really needed, to give Embree most freedom in choosing the best algorithm. E.g. in case Embree implements no packet traversers for some highly optimized data structure for single rays, then this data structure cannot be used if the user enables any ray packet query.</p>
<table>
<caption>Enabled algorithm flags for <code>rtcNewScene</code>.</caption>
<colgroup>
<col width="25%" />
<col width="72%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Algorithm Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_INTERSECT1</td>
<td align="left">Enables the <code>rtcIntersect</code> and <code>rtcOccluded</code> functions (single ray interface) for this scene.</td>
</tr>
<tr class="even">
<td align="left">RTC_INTERSECT4</td>
<td align="left">Enables the <code>rtcIntersect4</code> and <code>rtcOccluded4</code> functions (4-wide packet interface) for this scene.</td>
</tr>
<tr class="odd">
<td align="left">RTC_INTERSECT8</td>
<td align="left">Enables the <code>rtcIntersect8</code> and <code>rtcOccluded8</code> functions (8-wide packet interface) for this scene.</td>
</tr>
<tr class="even">
<td align="left">RTC_INTERSECT16</td>
<td align="left">Enables the <code>rtcIntersect16</code> and <code>rtcOccluded16</code> functions (16-wide packet interface) for this scene.</td>
</tr>
<tr class="odd">
<td align="left">RTC_INTERPOLATE</td>
<td align="left">Enables the <code>rtcInterpolate</code> and <code>rtcInterpolateN</code> interpolation functions.</td>
</tr>
</tbody>
</table>
<h2 id="geometries">Geometries</h2>
<p>Geometries are always contained in the scene they are created in. Each geometry is assigned an integer ID at creation time, which is unique for that scene. The current version of the API supports triangle meshes (<code>rtcNewTriangleMesh</code>), Catmull-Clark subdivision surfaces (<code>rtcNewSubdivisionMesh</code>), hair geometries (<code>rtcNewHairGeometry</code>), single level instances of other scenes (<code>rtcNewInstance</code>), and user defined geometries (<code>rtcNewUserGeometry</code>). The API is designed in a way that easily allows adding new geometry types in later releases.</p>
<p>For dynamic scenes, the assigned geometry IDs fulfill the following properties. As long as no geometry got deleted, all IDs are assigned sequentially, starting from 0. If geometries got deleted, the implementation will reuse IDs later on in an implementation dependent way. Consequently sequential assignment is no longer guaranteed, but a compact range of IDs. These rules allow the application to manage a dynamic array to efficiently map from geometry IDs to its own geometry representation.</p>
<p>For static scenes, geometry IDs are assigned sequentially starting at 0. This allows the application to use a fixed size array to map from geometry IDs to its own geometry representation.</p>
<p>Alternatively the application can also use the <code>void rtcSetUserData (RTCScene scene, unsigned geomID, void* ptr)</code> function to set a pointer <code>ptr</code> to its own geometry representation, and later read out this pointer again using the <code>void* rtcGetUserData (RTCScene scene, unsigned geomID)</code> function.</p>
<h3 id="triangle-meshes">Triangle Meshes</h3>
<p>Triangle meshes are created using the <code>rtcNewTriangleMesh</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call.</p>
<p>The number of triangles, the number of vertices, and optionally the number of time steps (1 for normal meshes, and 2 for linear motion blur) have to get specified at construction time of the mesh. The user can also specify additional flags that choose the strategy to handle that mesh in dynamic scenes. The following example demonstrates how to create a triangle mesh without motion blur:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewTriangleMesh(scene, geomFlags, numTriangles, numVertices);</code></pre>
<p>The following geometry flags can be specified at construction time of the triangle mesh:</p>
<table>
<caption>Flags for the creation of new geometries.</caption>
<colgroup>
<col width="34%" />
<col width="62%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Geometry Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_GEOMETRY_STATIC</td>
<td align="left">The mesh is considered static and should get modified rarely by the application. This flag has to get used in static scenes.</td>
</tr>
<tr class="even">
<td align="left">RTC_GEOMETRY_DEFORMABLE</td>
<td align="left">The mesh is considered to deform in a coherent way, e.g. a skinned character. The connectivity of the mesh has to stay constant, thus modifying the index array is not allowed. The implementation is free to choose a BVH refitting approach for handling meshes tagged with that flag.</td>
</tr>
<tr class="odd">
<td align="left">RTC_GEOMETRY_DYNAMIC</td>
<td align="left">The mesh is considered highly dynamic and changes frequently, possibly in an unstructured way. Embree will rebuild data structures from scratch for this type of mesh.</td>
</tr>
</tbody>
</table>
<p>The triangle indices can be set by mapping and writing to the index buffer (<code>RTC_INDEX_BUFFER</code>) and the triangle vertices can be set by mapping and writing into the vertex buffer (<code>RTC_VERTEX_BUFFER</code>). The index buffer contains an array of three 32 bit indices, while the vertex buffer contains an array of three float values aligned to 16 bytes. The 4th component of the aligned vertices can be arbitrary. All buffers have to get unmapped before an <code>rtcCommit</code> call to the scene.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Vertex   { <span class="dt">float</span> x, y, z, a; };
<span class="kw">struct</span> Triangle { <span class="dt">int</span> v0, v1, v2; };

Vertex* vertices = (Vertex*) rtcMapBuffer(scene, geomID, RTC_VERTEX_BUFFER);
<span class="co">// fill vertices here</span>
rtcUnmapBuffer(scene, geomID, RTC_VERTEX_BUFFER);

Triangle* triangles = (Triangle*) rtcMapBuffer(scene, geomID, RTC_INDEX_BUFFER);
<span class="co">// fill triangle indices here</span>
rtcUnmapBuffer(scene, geomID, RTC_INDEX_BUFFER);</code></pre>
<p>Also see tutorial <a href="tutorials.html#triangle-geometry">Triangle Geometry</a> for an example of how to create triangle meshes.</p>
<p>The parametrization of a triangle uses the first vertex <code>p0</code> as base point, and the vector <code>p1 - p0</code> as u-direction and <code>p2 - p0</code> as v-direction. The following picture additionally illustrates the direction the geometry normal is pointing into.</p>
<div class="figure">
<img src="images/triangle_uv.png" />

</div>
<p>Some texture coordinates <code>t0,t1,t2</code> can be linearly interpolated over the triangle the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">t_uv = (<span class="dv">1</span>-u-v)*t0 + u*(t1-t0) + v*(t2-t0)</code></pre>
<h3 id="subdivision-surfaces">Subdivision Surfaces</h3>
<p>Catmull-Clark subdivision surfaces for meshes consisting of triangle and quad primitives (even mixed inside one mesh) are supported, including support for edge creases, vertex creases, holes, and non-manifold geometry.</p>
<p>A subdivision surface is created using the <code>rtcNewSubdivisionMesh</code> function call, and deleted again using the <code>rtcDeleteGeometry</code> function call.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"> <span class="dt">unsigned</span> rtcNewSubdivisionMesh(RTCScene scene, 
                                RTCGeometryFlags flags,
                                size_t numFaces,
                                size_t numEdges,
                                size_t numVertices,
                                size_t numEdgeCreases,
                                size_t numVertexCreases,
                                size_t numCorners,
                                size_t numHoles,
                                size_t numTimeSteps);</code></pre>
<p>The number of faces (<code>numFaces</code>), edges/indices (<code>numEdges</code>), vertices (<code>numVertices</code>), edge creases (<code>numEdgeCreases</code>), vertex creases (<code>numVertexCreases</code>), holes (<code>numHoles</code>), and time steps (<code>numTimeSteps</code>) have to get specified at construction time.</p>
<p>The following buffers have to get setup by the application: the face buffer (<code>RTC_FACE_BUFFER</code>) contains the number edges/indices (3 or 4) of each of the <code>numFaces</code> faces, the index buffer (<code>RTC_INDEX_BUFFER</code>) contains multiple (3 or 4) 32 bit vertex indices for each face and <code>numEdges</code> indices in total, the vertex buffer (<code>RTC_VERTEX_BUFFER</code>) stores <code>numVertices</code> vertices as single precision <code>x</code>, <code>y</code>, <code>z</code> floating point coordinates aligned to 16 bytes. The value of the 4th float used for alignment can be arbitrary.</p>
<p>Optionally, the application can setup the hole buffer (<code>RTC_HOLE_BUFFER</code>) with <code>numHoles</code> many 32 bit indices of faces that should be considered non-existing.</p>
<p>Optionally, the application can fill the level buffer (<code>RTC_LEVEL_BUFFER</code>) with a tessellation level for each or the edges of each face, making a total of <code>numEdges</code> values. The tessellation level is a positive floating point value, that specifies how many quads along the edge should get generated during tessellation. The tessellation level is a lower bound, thus the implementation is free to choose a larger level. If no level buffer is specified a level of 1 is used. Note that some edge may be shared between (typically 2) faces. To guarantee a watertight tessellation, the level of these shared edges has to be exactly identical.</p>
<p>Optionally, the application can fill the sparse edge crease buffers to make some edges appear sharper. The edge crease index buffer (<code>RTC_EDGE_CREASE_INDEX_BUFFER</code>) contains <code>numEdgeCreases</code> many pairs of 32 bit vertex indices that specify unoriented edges. The edge crease weight buffer (<code>RTC_EDGE_CREASE_WEIGHT_BUFFER</code>) stores for each of theses crease edges a positive floating point weight. The larger this weight, the sharper the edge. Specifying a weight of infinity is supported and marks an edge as infinitely sharp. Storing an edge multiple times with the same crease weight is allowed, but has lower performance. Storing an edge multiple times with different crease weights results in undefined behavior. For a stored edge (i,j), the reverse direction edges (j,i) does not have to get stored, as both are considered the same edge.</p>
<p>Optionally, the application can fill the sparse vertex crease buffers to make some vertices appear sharper. The vertex crease index buffer (<code>RTC_VERTEX_CREASE_INDEX_BUFFER</code>), contains <code>numVertexCreases</code> many 32 bit vertex indices to specify a set of vertices. The vertex crease weight buffer (<code>RTC_VERTEX_CREASE_WEIGHT_BUFFER</code>) specifies for each of these vertices a positive floating point weight. The larger this weight, the sharper the vertex. Specifying a weight of infinity is supported and makes the vertex infinitely sharp. Storing a vertex multiple times with the same crease weight is allowed, but has lower performance. Storing a vertex multiple times with different crease weights results in undefined behavior.</p>
<p>One triangles and quadrilaterals are supported as primitives of a subdivision mesh. The parametrization of a triangle uses the first vertex <code>p0</code> as base point, and the vector <code>p1 - p0</code> as u-direction and <code>p2 - p0</code> as v-direction. The following picture additionally illustrates the direction the geometry normal is pointing into.</p>
<div class="figure">
<img src="images/triangle_uv.png" />

</div>
<p>Some texture coordinates <code>t0,t1,t2</code> can be linearly interpolated over the triangle the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">t_uv = (<span class="dv">1</span>-u-v)*t0 + u*(t1-t0) + v*(t2-t0)</code></pre>
<p>The parametrization of a quadrilateral uses the first vertex <code>p0</code> as base point, and the vector <code>p1 - p0</code> as u-direction and <code>p3 - p0</code> as v-direction. The following picture additionally illustrates the direction the geometry normal is pointing into.</p>
<div class="figure">
<img src="images/quad_uv.png" />

</div>
<p>Some texture coordinates <code>t0,t1,t2,t3</code> can be bi-linearly interpolated over the quadrilateral the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">t_uv = (<span class="dv">1</span>-v)((<span class="dv">1</span>-u)*t0 + u*t1) + v*((<span class="dv">1</span>-u)*t3 + u*t2) </code></pre>
<p>To smoothly interpolate texture coordinates over the subdivision surface we recommend using the <code>rtcInterpolate</code> function, which will apply the standard subdivision rules for interpolation.</p>
<p>Using the <code>rtcSetBoundaryMode</code> API call one can specify how corner vertices are handled. Specifying <code>RTC_BOUNDARY_NONE</code> ignores all boundary patches, <code>RTC_BOUNDARY_EDGE_ONLY</code> makes all boundaries soft, while <code>RTC_BOUNDARY_EDGE_AND_CORNER</code> makes corner vertices sharp.</p>
<p>The user can also specify a geometry mask and additional flags that choose the strategy to handle that subdivision mesh in dynamic scenes.</p>
<p>The implementation of subdivision surfaces uses an internal software cache, which can get configured to some desired size (see <a href="#configuring-embree">Configuring Embree</a>).</p>
<p>Also see tutorial <a href="tutorials.html#subdivision-geometry">Subdivision Geometry</a> for an example of how to create subdivision surfaces.</p>
<h3 id="hair-geometry">Hair Geometry</h3>
<p>Hair geometries are supported, which consist of multiple hairs represented as cubic Bézier curves with varying radius per control point. Individual hairs are considered to be subpixel sized which allows the implementation to approximate the intersection calculation. This in particular means that zooming onto one hair might show geometric artifacts.</p>
<p>Hair geometries are created using the <code>rtcNewHairGeometry</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call.</p>
<p>The number of hair curves, the number of vertices, and optionally the number of time steps (1 for normal curves, and 2 for linear motion blur) have to get specified at construction time of the hair geometry.</p>
<p>The curve indices can be set by mapping and writing to the index buffer (<code>RTC_INDEX_BUFFER</code>) and the control vertices can be set by mapping and writing into the vertex buffer (<code>RTC_VERTEX_BUFFER</code>). In case of linear motion blur, two vertex buffers (<code>RTC_VERTEX_BUFFER0</code> and <code>RTC_VERTEX_BUFFER1</code>) have to get filled, one for each time step.</p>
<p>The index buffer contains an array of 32 bit indices pointing to the ID of the first of four control vertices, while the vertex buffer stores all control points in the form of a single precision position and radius stored in <code>x</code>, <code>y</code>, <code>z</code>, <code>r</code> order in memory. The hair radii have to be greater or equal zero. All buffers have to get unmapped before an <code>rtcCommit</code> call to the scene.</p>
<p>Like for triangle meshes, the user can also specify a geometry mask and additional flags that choose the strategy to handle that mesh in dynamic scenes.</p>
<p>The following example demonstrates how to create some hair geometry:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewHairGeometry(scene, geomFlags, numCurves, numVertices);

<span class="kw">struct</span> Vertex { <span class="dt">float</span> x, y, z, r; };

Vertex* vertices = (Vertex*) rtcMapBuffer(scene, geomID, RTC_VERTEX_BUFFER);
<span class="co">// fill vertices here</span>
rtcUnmapBuffer(scene, geomID, RTC_VERTEX_BUFFER);

<span class="dt">int</span>* curves = (<span class="dt">int</span>*) rtcMapBuffer(scene, geomID, RTC_INDEX_BUFFER);
<span class="co">// fill indices here</span>
rtcUnmapBuffer(scene, geomID, RTC_INDEX_BUFFER);</code></pre>
<p>Also see tutorial <a href="tutorials.html#hair">Hair</a> for an example of how to create and use hair geometry.</p>
<h3 id="user-defined-geometry">User Defined Geometry</h3>
<p>User defined geometries make it possible to extend Embree with arbitrary types of geometry. This is achieved by introducing arrays of user geometries as a special geometry type. These objects do not contain a single user geometry, but a set of such geometries, each specified by an index. The user has to provide a user data pointer, bounding function as well as user defined intersect and occluded functions to create a set of user geometries. The user geometry to process is specified by passing its user data pointer and index to each invocation of the bounding, intersect, and occluded function. The bounding function is used to query the bounds of each user geometry. When performing ray queries, Embree will invoke the user intersect (and occluded) functions to test rays for intersection (and occlusion) with the specified user defined geometry.</p>
<p>As Embree supports different ray packet sizes, one potentially has to provide different versions of user intersect and occluded function pointers for these packet sizes. However, the ray packet size of the called user function always matches the packet size of the originally invoked ray query function. Consequently, an application only operating on single rays only has to provide single ray intersect and occluded function pointers.</p>
<p>User geometries are created using the <code>rtcNewUserGeometry</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call. The following example illustrates creating an array with two user geometries:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> UserObject { ... };

<span class="dt">void</span> userBoundsFunction(UserObject* userGeom, size_t i, RTCBounds&amp; bounds) {
  bounds = &lt;bounds of userGeom[i]&gt;;
}

<span class="dt">void</span> userIntersectFunction(UserObject* userGeom, RTCRay&amp; ray, size_t i) {
  <span class="kw">if</span> (&lt;ray misses userGeom[i]&gt;)
    <span class="kw">return</span>;
  &lt;update ray hit information&gt;;
}

<span class="dt">void</span> userOccludedFunction(UserObject* userGeom, RTCRay&amp; ray, size_t i) {
  <span class="kw">if</span> (&lt;ray misses userGeom[i]&gt;)
    <span class="kw">return</span>;
  geomID = <span class="dv">0</span>;
}

...

UserObject* userGeom = <span class="kw">new</span> UserObject[<span class="dv">2</span>];
userGeom[<span class="dv">0</span>] = ...
userGeom[<span class="dv">1</span>] = ...
<span class="dt">unsigned</span> geomID = rtcNewUserGeometry(scene, <span class="dv">2</span>);
rtcSetUserData(scene, geomID, userGeom);
rtcSetBounds(scene, geomID, userBoundsFunction);
rtcSetIntersectFunction(scene, geomID, userIntersectFunction);
rtcSetOccludedFunction(scene, geomID, userOccludedFunction);</code></pre>
<p>The user intersect function (<code>userIntersectFunction</code>) and user occluded function (<code>userOccludedFunction</code>) get as input the pointer provided through the <code>rtcSetUserData</code> function call, a ray, and the index of the geometry to process. For ray packets, the user intersect and occluded functions also get a pointer to a valid mask as input. The user provided functions should not modify any ray that is disabled by that valid mask.</p>
<p>The user intersect function should return without modifying the ray structure if the user geometry is missed. If the geometry is hit, it has to update the hit information of the ray (<code>tfar</code>, <code>u</code>, <code>v</code>, <code>Ng</code>, <code>geomID</code>, <code>primID</code>).</p>
<p>Also the user occluded function should return without modifying the ray structure if the user geometry is missed. If the geometry is hit, it should set the <code>geomID</code> member of the ray to 0.</p>
<p>See tutorial <a href="tutorials.html#user-geometry">User Geometry</a> for an example of how to use the user defined geometries.</p>
<h3 id="instances">Instances</h3>
<p>Embree supports instancing of scenes inside another scene by some transformation. As the instanced scene is stored only a single time, even if instanced to multiple locations, this feature can be used to create extremely large scenes. Only single level instancing is supported by Embree natively, however, multi-level instancing can principally be implemented through user geometries.</p>
<p>Instances are created using the <code>rtcNewInstance</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call. To instantiate a scene, one first has to generate the scene B to instantiate. Now one can add an instance of this scene inside a scene A the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> instID = rtcNewInstance(sceneA, sceneB);
rtcSetTransform(sceneA, instID, RTC_MATRIX_COLUMN_MAJOR, &amp;column_matrix_3x4);</code></pre>
<p>One has to call <code>rtcCommit</code> on scene B before one calls <code>rtcCommit</code> on scene A. When modifying scene B one has to call <code>rtcUpdate</code> for all instances of that scene. If a ray hits the instance, then the <code>geomID</code> and <code>primID</code> members of the ray are set to the geometry ID and primitive ID of the primitive hit in scene B, and the <code>instID</code> member of the ray is set to the instance ID returned from the <code>rtcNewInstance</code> function.</p>
<p>The <code>rtcSetTransform</code> call can be passed an affine transformation matrix with different data layouts:</p>
<table>
<caption>Matrix layouts for <code>rtcSetTransform</code>.</caption>
<colgroup>
<col width="48%" />
<col width="48%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Layout</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_MATRIX_ROW_MAJOR</td>
<td align="left">The 3×4 float matrix is laid out in row major form.</td>
</tr>
<tr class="even">
<td align="left">RTC_MATRIX_COLUMN_MAJOR</td>
<td align="left">The 3×4 float matrix is laid out in column major form.</td>
</tr>
<tr class="odd">
<td align="left">RTC_MATRIX_COLUMN_MAJOR_ALIGNED16</td>
<td align="left">The 3×4 float matrix is laid out in column major form, with each column padded by an additional 4th component.</td>
</tr>
</tbody>
</table>
<p>Passing homogeneous 4×4 matrices is possible as long as the last row is (0, 0, 0, 1). If this homogeneous matrix is laid out in row major form, use the <code>RTC_MATRIX_ROW_MAJOR</code> layout. If this homogeneous matrix is laid out in column major form, use the <code>RTC_MATRIX_COLUMN_MAJOR_ALIGNED16</code> mode. In both cases, Embree will ignore the last row of the matrix.</p>
<p>The transformation passed to <code>rtcSetTransform</code> transforms from the local space of the instantiated scene to world space.</p>
<p>See tutorial <a href="tutorials.html#instanced-geometry">Instanced Geometry</a> for an example of how to use instances.</p>
<h2 id="ray-queries">Ray Queries</h2>
<p>The API supports finding the closest hit of a ray segment with the scene (<code>rtcIntersect</code> functions), and determining if any hit between a ray segment and the scene exists (<code>rtcOccluded</code> functions).</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcIntersect  (                   RTCScene scene, RTCRay&amp;   ray);
<span class="dt">void</span> rtcIntersect4 (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay4&amp;  ray);
<span class="dt">void</span> rtcIntersect8 (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay8&amp;  ray);
<span class="dt">void</span> rtcIntersect16(<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay16&amp; ray);
<span class="dt">void</span> rtcOccluded   (                   RTCScene scene, RTCRay&amp;   ray);
<span class="dt">void</span> rtcOccluded4  (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay4&amp;  ray);
<span class="dt">void</span> rtcOccluded8  (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay8&amp;  ray);
<span class="dt">void</span> rtcOccluded16 (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay16&amp; ray);</code></pre>
<p>The ray layout to be passed to the ray tracing core is defined in the <code>embree2/rtcore_ray.h</code> header file. It is up to the user if he wants to use the ray structures defined in that file, or resemble the exact same binary data layout with their own vector classes. The ray layout might change with new Embree releases as new features get added, however, will stay constant as long as the major Embree release number does not change. The ray contains the following data members:</p>
<table>
<caption>Data fields of a ray.</caption>
<thead>
<tr class="header">
<th align="left">Member</th>
<th align="left">In/Out</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">org</td>
<td align="left">in</td>
<td align="left">ray origin</td>
</tr>
<tr class="even">
<td align="left">dir</td>
<td align="left">in</td>
<td align="left">ray direction (can be unnormalized)</td>
</tr>
<tr class="odd">
<td align="left">tnear</td>
<td align="left">in</td>
<td align="left">start of ray segment</td>
</tr>
<tr class="even">
<td align="left">tfar</td>
<td align="left">in/out</td>
<td align="left">end of ray segment, set to hit distance after intersection</td>
</tr>
<tr class="odd">
<td align="left">time</td>
<td align="left">in</td>
<td align="left">time used for motion blur</td>
</tr>
<tr class="even">
<td align="left">mask</td>
<td align="left">in</td>
<td align="left">ray mask to mask out geometries</td>
</tr>
<tr class="odd">
<td align="left">Ng</td>
<td align="left">out</td>
<td align="left">unnormalized geometry normal</td>
</tr>
<tr class="even">
<td align="left">u</td>
<td align="left">out</td>
<td align="left">barycentric u-coordinate of hit</td>
</tr>
<tr class="odd">
<td align="left">v</td>
<td align="left">out</td>
<td align="left">barycentric v-coordinate of hit</td>
</tr>
<tr class="even">
<td align="left">geomID</td>
<td align="left">out</td>
<td align="left">geometry ID of hit geometry</td>
</tr>
<tr class="odd">
<td align="left">primID</td>
<td align="left">out</td>
<td align="left">primitive ID of hit primitive</td>
</tr>
<tr class="even">
<td align="left">instID</td>
<td align="left">out</td>
<td align="left">instance ID of hit instance</td>
</tr>
</tbody>
</table>
<p>This structure is in struct of array layout (SOA) for ray packets. Note that the <code>tfar</code> member functions as an input and output.</p>
<p>In the ray packet mode (with packet size of N), the user has to provide a pointer to N 32 bit integers that act as a ray activity mask. If one of these integers is set to <code>0x00000000</code> the corresponding ray is considered inactive and if the integer is set to <code>0xFFFFFFFF</code>, the ray is considered active. Rays that are inactive will not update any hit information. Data alignment requirements for ray query functions operating on single rays is 16 bytes for the ray.</p>
<p>Data alignment requirements for query functions operating on AOS packets of 4, 8, or 16 rays, is 16, 32, and 64 bytes respectively, for the valid mask and the ray. To operate on packets of 4 rays, the CPU has to support SSE, to operate on packets of 8 rays, the CPU has to support AVX-256, and to operate on packets of 16 rays, the CPU has to support the Intel® Xeon Phi™ coprocessor instructions. Additionally, the required ISA has to be enabled in Embree at compile time to use the desired packet size.</p>
<p>Finding the closest hit distance is done through the <code>rtcIntersect</code> functions. These get the activity mask, the scene, and a ray as input. The user has to initialize the ray origin (<code>org</code>), ray direction (<code>dir</code>), and ray segment (<code>tnear</code>, <code>tfar</code>). The ray segment has to be in the range <span class="math">[0, ∞)</span>, thus ranges that start behind the ray origin are not valid, but ranges can reach to infinity. The geometry ID (<code>geomID</code> member) has to get initialized to <code>RTC_INVALID_GEOMETRY_ID</code> (-1). If the scene contains instances, also the instance ID (<code>instID</code>) has to get initialized to <code>RTC_INVALID_GEOMETRY_ID</code> (-1). If the scene contains linear motion blur, also the ray time (<code>time</code>) has to get initialized to a value in the range <span class="math">[0, 1]</span>. If ray masks are enabled at compile time, also the ray mask (<code>mask</code>) has to get initialized. After tracing the ray, the hit distance (<code>tfar</code>), geometry normal (<code>Ng</code>), local hit coordinates (<code>u</code>, <code>v</code>), geometry ID (<code>geomID</code>), and primitive ID (<code>primID</code>) are set. If the scene contains instances, also the instance ID (<code>instID</code>) is set, if an instance is hit. The geometry ID corresponds to the ID returned at creation time of the hit geometry, and the primitive ID corresponds to the <span class="math"><em>n</em></span>th primitive of that geometry, e.g. <span class="math"><em>n</em></span>th triangle. The instance ID corresponds to the ID returned at creation time of the instance.</p>
<p>The following code properly sets up a ray and traces it through the scene:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCRay ray;
ray.org = ray_origin;
ray.dir = ray_direction;
ray.tnear = <span class="fl">0.f</span>;
ray.tfar = inf;
ray.geomID = RTC_INVALID_GEOMETRY_ID;
ray.primID = RTC_INVALID_GEOMETRY_ID;
ray.instID = RTC_INVALID_GEOMETRY_ID;
ray.mask = <span class="bn">0xFFFFFFFF</span>;
ray.time = <span class="fl">0.f</span>;
rtcIntersect(scene, ray);</code></pre>
<p>Testing if any geometry intersects with the ray segment is done through the <code>rtcOccluded</code> functions. Initialization has to be done as for <code>rtcIntersect</code>. If some geometry got found along the ray segment, the geometry ID (<code>geomID</code>) will get set to 0. Other hit information of the ray is undefined after calling <code>rtcOccluded</code>.</p>
<p>See tutorial <a href="tutorials.html#triangle-geometry">Triangle Geometry</a> for an example of how to trace rays.</p>
<h2 id="interpolation-of-vertex-data">Interpolation of Vertex Data</h2>
<p>Smooth interpolation of per-vertex data is supported for triangle meshes, hair geometry, and subdivision geometry using the <code>rtcInterpolate</code> API call.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcInterpolate(RTCScene scene,
                    <span class="dt">unsigned</span> geomID, <span class="dt">unsigned</span> primID,
                    <span class="dt">float</span> u, <span class="dt">float</span> v,
                    RTCBufferType buffer, 
                    <span class="dt">float</span>* P, <span class="dt">float</span>* dPdu, <span class="dt">float</span>* dPdv,
                    size_t numFloats);</code></pre>
<p>This call smoothly interpolates the per-vertex data stored in the specified geometry buffer (<code>buffer</code> parameter) to the u/v location (<code>u</code> and <code>v</code> parameters) of the primitive (<code>primID</code> parameter) of the geometry (<code>geomID</code> parameter) of the specified scene (<code>scene</code> parameter). The interpolation buffer (<code>buffer</code> parameter) has to contain (at least) <code>numFloats</code> floating point values per vertex to interpolate. As interpolation buffer one can specify the <code>RTC_VERTEX_BUFFER0</code> and <code>RTC_VERTEX_BUFFER1</code> as well as one of two special user vertex buffers <code>RTC_USER_VERTEX_BUFFER0</code> and <code>RTC_USER_VERTEX_BUFFER1</code>. These user vertex buffers can only get set using the <code>rtcSetBuffer</code> call, they cannot get managed internally by Embree as they have no default layout. The last element of the buffer has to be padded to 16 bytes, such that it can be read safely using SSE instructions.</p>
<p>The <code>rtcInterpolate</code> call stores <code>numFloats</code> interpolated floating point values to the memory location pointed to by <code>P</code>. The derivative of the interpolation by u and v are stored at <code>dPdu</code> and <code>dPdv</code>. The <code>P</code> pointer can be NULL to avoid calculating the interpolated value. Similar the <code>dPdu</code> and <code>dPdv</code> parameters can both be NULL to not calculate derivatives. If <code>dPdu</code> is NULL also <code>dPdv</code> has to be NULL.</p>
<p>The <code>RTC_INTERPOLATE</code> algorithm flag of a scene has to be enabled to perform interpolations.</p>
<p>It is explicitely allowed to call this function on disabled geometries. This makes it possible to use a separate subdivision mesh with different vertex creases, edge creases, and boundary handling for interpolation of texture coordinates if that is necessary.</p>
<p>The applied interpolation will do linear interpolation for triangle meshes, cubic Bézier interpolation for hair, and apply the full subdivision rules for subdivision geometry.</p>
<p>There is also a second interpolate call <code>rtcInterpolateN</code> that can be used for ray packets.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcInterpolateN(RTCScene scene, <span class="dt">unsigned</span> geomID, 
                     <span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">const</span> <span class="dt">unsigned</span>* primIDs,
                     <span class="dt">const</span> <span class="dt">float</span>* u, <span class="dt">const</span> <span class="dt">float</span>* v, size_t numUVs, 
                     RTCBufferType buffer, 
                     <span class="dt">float</span>* dP, <span class="dt">float</span>* dPdu, <span class="dt">float</span>* dPdv,
                     size_t numFloats);</code></pre>
<p>This call is similar to the first version, but gets passed <code>numUVs</code> many u/v coordinates and a valid mask (<code>valid</code> parameter) that specifies which of these coordinates are valid. The valid mask points to <code>numUVs</code> integers and a value of -1 denotes valid and 0 invalid. If the valid pointer is NULL all elements are considers valid. The destination arrays are filled in structure of array (SoA) layout.</p>
<p>See tutorial <a href="tutorials.html#interpolation">Interpolation</a> for an example of using the <code>rtcInterpolate</code> function.</p>
<h2 id="buffer-sharing">Buffer Sharing</h2>
<p>Embree supports sharing of buffers with the application. Each buffer that can be mapped for a specific geometry can also be shared with the application, by pass a pointer, offset, and stride of the application side buffer using the <code>rtcSetBuffer</code> API function.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetBuffer(RTCScene scene, <span class="dt">unsigned</span> geomID, RTCBufferType type,
                  <span class="dt">void</span>* ptr, size_t offset, size_t stride);</code></pre>
<p>The <code>rtcSetBuffer</code> function has to get called before any call to <code>rtcMapBuffer</code> for that buffer, otherwise the buffer will get allocated internally and the call to <code>rtcSetBuffer</code> will fail. The buffer has to remain valid as long as the geometry exists, and the user is responsible to free the buffer when the geometry gets deleted. When a buffer is shared, it is safe to modify that buffer without mapping and unmapping it. However, for dynamic scenes one still has to call <code>rtcUpdate</code> for modified geometries and the buffer data has to stay constant from the <code>rtcCommit</code> call to after the last ray query invocation.</p>
<p>The <code>offset</code> parameter specifies a byte offset to the start of the first element and the <code>stride</code> parameter specifies a byte stride between the different elements of the shared buffer. This support for offset and stride allows the application quite some freedom in the data layout of these buffers, however, some restrictions apply. Index buffers always store 32 bit indices and vertex buffers always store single precision floating point data. The start address ptr+offset and stride always have to be aligned to 4 bytes on Intel® Xeon® CPUs and 16 bytes on Xeon Phi accelerators, otherwise the <code>rtcSetBuffer</code> function will fail.</p>
<p>For vertex buffers (<code>RTC_VERTEX_BUFFER</code> and <code>RTC_USER_VERTEX_BUFFER</code>), the last element must be readable using SSE instructions, thus padding the last element to 16 bytes size is required for some layouts.</p>
<p>The following is an example of how to create a mesh with shared index and vertex buffers:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewTriangleMesh(scene, geomFlags, numTriangles, numVertices);
rtcSetBuffer(scene, geomID, RTC_VERTEX_BUFFER, vertexPtr, <span class="dv">0</span>, <span class="dv">3</span>*<span class="kw">sizeof</span>(<span class="dt">float</span>));
rtcSetBuffer(scene, geomID, RTC_INDEX_BUFFER, indexPtr, <span class="dv">0</span>, <span class="dv">3</span>*<span class="kw">sizeof</span>(<span class="dt">int</span>));</code></pre>
<p>Sharing buffers can significantly reduce the memory required by the application, thus we recommend using this feature. When enabling the <code>RTC_COMPACT</code> scene flag, the spatial index structures of Embree might also share the vertex buffer, resulting in even higher memory savings.</p>
<p>The support for offset and stride is enabled by default, but can get disabled at compile time using the <code>RTCORE_BUFFER_STRIDE</code> parameter in CMake. Disabling this feature enables the default offset and stride which increases performance of spatial index structure build, thus can be useful for dynamic content.</p>
<h2 id="linear-motion-blur">Linear Motion Blur</h2>
<p>Triangle meshes and hair geometries with linear motion blur support are created by setting the number of time steps to 2 at geometry construction time. Specifying a number of time steps of 0 or larger than 2 is invalid. For a triangle mesh or hair geometry with linear motion blur, the user has to set the <code>RTC_VERTEX_BUFFER0</code> and <code>RTC_VERTEX_BUFFER1</code> vertex arrays, one for each time step.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewTriangleMesh(scene, geomFlags, numTris, numVertices, <span class="dv">2</span>);
rtcSetBuffer(scene, geomID, RTC_VERTEX_BUFFER0, vertex0Ptr, <span class="dv">0</span>, <span class="kw">sizeof</span>(Vertex));
rtcSetBuffer(scene, geomID, RTC_VERTEX_BUFFER1, vertex1Ptr, <span class="dv">0</span>, <span class="kw">sizeof</span>(Vertex));
rtcSetBuffer(scene, geomID, RTC_INDEX_BUFFER, indexPtr, <span class="dv">0</span>, <span class="kw">sizeof</span>(Triangle));</code></pre>
<p>If a scene contains geometries with linear motion blur, the user has to set the <code>time</code> member of the ray to a value in the range <span class="math">[0, 1]</span>. The ray will intersect the scene with the vertices of the two time steps linearly interpolated to this specified time. Each ray can specify a different time, even inside a ray packet.</p>
<h2 id="user-data-pointer">User Data Pointer</h2>
<p>A user data pointer can be specified and queried per geometry, to efficiently map from the geometry ID returned by ray queries to the application representation for that geometry.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span>  rtcSetUserData (RTCScene scene, <span class="dt">unsigned</span> geomID, <span class="dt">void</span>* ptr);
<span class="dt">void</span>* rtcGetUserData (RTCScene scene, <span class="dt">unsigned</span> geomID);</code></pre>
<p>The user data pointer of some user defined geometry get additionally passed to the intersect and occluded callback functions of that user geometry. Further, the user data pointer is also passed to intersection filter callback functions attached to some geometry.</p>
<p>The <code>rtcGetUserData</code> function is on purpose not thread safe with respect to other API calls that modify the scene. Consequently, this function can be used to efficiently query the user data pointer during rendering (also by multiple threads), but should not get called while modifying the scene with other threads.</p>
<h2 id="geometry-mask">Geometry Mask</h2>
<p>A 32 bit geometry mask can be assigned to triangle meshes and hair geometries using the <code>rtcSetMask</code> call.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetMask(scene, geomID, mask);</code></pre>
<p>Only if the bitwise <code>and</code> operation of this mask with the mask stored inside the ray is not 0, primitives of this geometry are hit by a ray. This feature can be used to disable selected triangle mesh or hair geometries for specifically tagged rays, e.g. to disable shadow casting for some geometry. This API feature is disabled in Embree by default at compile time, and can be enabled in CMake through the <code>RTCORE_ENABLE_RAY_MASK</code> parameter.</p>
<h2 id="filter-functions">Filter Functions</h2>
<p>The API supports per geometry filter callback functions that are invoked for each intersection found during the <code>rtcIntersect</code> or <code>rtcOccluded</code> calls. The former ones are called intersection filter functions, the latter ones occlusion filter functions. The filter functions can be used to implement various useful features, such as accumulating opacity for transparent shadows, counting the number of surfaces along a ray, collecting all hits along a ray, etc. Filter functions can also be used to selectively reject hits to enable backface culling for some geometries. If the backfaces should be culled in general for all geometries then it is faster to enable <code>RTCORE_BACKFACE_CULLING</code> during compilation of Embree instead of using filter functions.</p>
<p>The filter functions provided by the user have to have the following signature:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> FilterFunc  (                   <span class="dt">void</span>* userPtr, RTCRay&amp;   ray);
<span class="dt">void</span> FilterFunc4 (<span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">void</span>* userPtr, RTCRay4&amp;  ray);
<span class="dt">void</span> FilterFunc8 (<span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">void</span>* userPtr, RTCRay8&amp;  ray);
<span class="dt">void</span> FilterFunc16(<span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">void</span>* userPtr, RTCRay16&amp; ray);</code></pre>
<p>The <code>valid</code> pointer points to a valid mask of the same format as expected as input by the ray query functions. The <code>userPtr</code> is a user pointer optionally set per geometry through the <code>rtcSetUserData</code> function. The ray passed to the filter function is the ray structure initially provided to the ray query function by the user. For that reason, it is safe to extend the ray by additional data and access this data inside the filter function (e.g. to accumulate opacity). All hit information inside the ray is valid. If the hit geometry is instanced, the <code>instID</code> member of the ray is valid and the ray origin, direction, and geometry normal visible through the ray are in object space. The filter function can reject a hit by setting the <code>geomID</code> member of the ray to <code>RTC_INVALID_GEOMETRY_ID</code>, otherwise the hit is accepted. The filter function is not allowed to modify the ray input data (<code>org</code>, <code>dir</code>, <code>tnear</code>, <code>tfar</code>), but can modify the hit data of the ray (<code>u</code>, <code>v</code>, <code>Ng</code>, <code>geomID</code>, <code>primID</code>).</p>
<p>The intersection filter functions for different ray types are set for some geometry of a scene using the following API functions:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetIntersectionFilterFunction  (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc  );
<span class="dt">void</span> rtcSetIntersectionFilterFunction4 (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc4 );
<span class="dt">void</span> rtcSetIntersectionFilterFunction8 (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc8 );
<span class="dt">void</span> rtcSetIntersectionFilterFunction16(RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc16);</code></pre>
<p>These functions are invoked during execution of the <code>rtcIntersect</code> type queries of the matching ray type. The occlusion filter functions are set using the following API functions:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetOcclusionFilterFunction  (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc  );
<span class="dt">void</span> rtcSetOcclusionFilterFunction4 (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc4 );
<span class="dt">void</span> rtcSetOcclusionFilterFunction8 (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc8 );
<span class="dt">void</span> rtcSetOcclusionFilterFunction16(RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc16);</code></pre>
<p>See tutorial <a href="tutorials.html#intersection-filter">Intersection Filter</a> for an example of how to use the filter functions.</p>
<h2 id="displacement-mapping-functions">Displacement Mapping Functions</h2>
<p>The API supports displacement mapping for subdivision meshes. A displacement function can be set for some subdivision mesh using the <code>rtcSetDisplacementFunction</code> API call.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetDisplacementFunction(RTCScene, <span class="dt">unsigned</span> geomID, RTCDisplacementFunc, RTCBounds*);</code></pre>
<p>A displacement function of <code>NULL</code> will delete an already set displacement function. The bounds parameter is optional. If <code>NULL</code> is passed as bounds, then the displacement shader will get evaluated during the build process to properly bound displaced geometry. If a pointer to some bounds of the displacement are passed, then the implementation can choose to use these bounds to bound displaced geometry. When bounds are specified, then these bounds have to be conservative and should be tight for best performance.</p>
<p>The displacement function has to have the following type:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">void</span> (*RTCDisplacementFunc)(<span class="dt">void</span>* ptr, <span class="dt">unsigned</span> geomID, <span class="dt">unsigned</span> primID,   
                                    <span class="dt">const</span> <span class="dt">float</span>* u,  <span class="dt">const</span> <span class="dt">float</span>* v,    
                                    <span class="dt">const</span> <span class="dt">float</span>* nx, <span class="dt">const</span> <span class="dt">float</span>* ny, <span class="dt">const</span> <span class="dt">float</span>* nz,   
                                    <span class="dt">float</span>* px, <span class="dt">float</span>* py, <span class="dt">float</span>* pz,         
                                    size_t N);</code></pre>
<p>The displacement function is called with the user data pointer of the geometry (<code>ptr</code>), the geometry ID (<code>geomID</code>) and primitive ID (<code>primID</code>) of a patch to displace. For this patch, a number N of points to displace are specified in a struct of array layout. For each point to displace the local patch UV coordinates (<code>u</code> and <code>v</code> arrays), the normalized geometry normal (<code>nx</code>, <code>ny</code>, and <code>nz</code> arrays), as well as world space position (<code>px</code>, <code>py</code>, and <code>pz</code> arrays) are provided. The task of the displacement function is to use this information and move the world space position inside the allowed specified bounds around the point.</p>
<p>All passed arrays are guaranteed to be 64 bytes aligned, and properly padded to make wide vector processing inside the displacement function possible.</p>
<p>The displacement mapping functions might get called during the <code>rtcCommit</code> call, or lazily during the <code>rtcIntersect</code> or <code>rtcOccluded</code> calls.</p>
<p>Also see tutorial <a href="tutorials.html#displacement-geometry">Displacement Geometry</a> for an example of how to use the displacement mapping functions.</p>
<h2 id="sharing-threads-with-embree">Sharing Threads with Embree</h2>
<p>On some implementations, Embree supports using the application threads when building internal data structures, by using the</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcCommitThread(RTCScene, <span class="dt">unsigned</span> threadIndex, <span class="dt">unsigned</span> threadCount);</code></pre>
<p>API call to commit the scene. This function has to get called by all threads that want to cooperate in the scene commit. Each call is provided the scene to commit, the index of the calling thread in the range [0, <code>threadCount</code>-1], and the number of threads that will call into this commit operation for the scene. All threads will return again from this function after the scene commit is finished.</p>
<p>Multiple such scene commit operations can also be running at the same time, e.g. it is possible to commit many small scenes in parallel using one thread per commit operation. Subsequent commit operations for the same scene can use different number of threads in the <code>rtcCommitThread</code> or use the Embree internal threads using the <code>rtcCommit</code> call.</p>
<p><em>Note:</em> When using Embree with the Intel® Threading Building Blocks (which is the default) you should not use the <code>rtcCommitThread</code> function. Sharing of your threads with TBB is not possible and TBB will always generate its own set of threads. We recommend to also use TBB inside your application to share threads with the Embree library. When using TBB inside your application do never use the <code>rtcCommitThread</code> function.</p>
<p><em>Note:</em> When enabling the Embree internal tasking system the <code>rtcCommitThread</code> feature will work as expected and use the application threads for hierarchy building.</p>
<p><em>Note:</em> On the Intel® Xeon Phi™ coprocessor the <code>rtcCommitThread</code> feature is recommended to be used.</p>
<h2 id="join-build-operation">Join Build Operation</h2>
<p>If <code>rtcCommit</code> is called multiple times from different threads on the same scene, then all these threads will join the same scene build operation.</p>
<p>This feature allows a flexible way to lazily create hierarchies during rendering. A thread reaching a not yet constructed sub-scene of a two-level scene, can generate the sub-scene geometry and call <code>rtcCommit</code> on that just generated scene. During construction, further threads reaching the not-yet-built scene, can join the build operation by also invoking <code>rtcCommit</code>. A thread that calls <code>rtcCommit</code> after the build finishes, will directly return from the <code>rtcCommit</code> call (even for static scenes).</p>
<p><em>Note:</em> Due to some limitation of the task_arena implementation of the Intel® Threading Building Blocks, threads that call <code>rtcCommit</code> to join a running build will just wait for the build to finish. Thus the join mode does just not work properly when using TBB, and might cause the build to run sequential (if all threads want to join).</p>
<p><em>Note:</em> The join mode works properly with the internal tasking scheduler of Embree.</p>
<h2 id="memory-monitor-callback">Memory Monitor Callback</h2>
<p>Using the memory monitor callback mechanism, the application can track the memory consumption of Embree, and optionally terminate API calls that consume too much memory.</p>
<p>The user provided memory monitor callback function has to have the following signature:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> (*RTCMemoryMonitorFunc)(<span class="dt">const</span> ssize_t bytes, <span class="dt">const</span> <span class="dt">bool</span> post);</code></pre>
<p>A single such callback function can be registered by calling</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetMemoryMonitorFunction(RTCMemoryMonitorFunc func);</code></pre>
<p>and deregistered again by calling it with <code>NULL</code>. Once registered Embree will invoke the callback function before or after it allocates or frees important memory blocks. The callback function might get called from multiple threads concurrently.</p>
<p>The application can track the current memory usage of the Embree library by atomically accumulating the provided <code>bytes</code> input parameter. This parameter will be &gt;0 for allocations and &lt;0 for deallocations. The <code>post</code> input parameter is true if the callback function was invoked after the allocation or deallocation, otherwise it is false.</p>
<p>Embree will continue its operation normally when returning true from the callback function. If false is returned, Embree will cancel the current operation with the RTC_OUT_OF_MEMORY error code. Cancelling will only happen when the callback was called for allocations (bytes &gt; 0), otherwise the cancel request will be ignored. If a callback that was invoked before the allocation happens (<code>post == false</code>) cancels the operation, then the <code>bytes</code> parameter should not get accumulated, as the allocation will never happen. If a callback that was called after the allocation happened (<code>post == true</code>) cancels the operation, then the <code>bytes</code> parameter should get accumulated, as the allocation properly happened. Issuing multiple cancel requests for the same operation is allowed.</p>
<h2 id="progress-monitor-callback">Progress Monitor Callback</h2>
<p>The progress monitor callback mechanism can be used to report progress of hierarchy build operations and to cancel long lasting build operations.</p>
<p>The user provided progress monitor callback function has to have the following signature:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> (*RTCProgressMonitorFunc)(<span class="dt">void</span>* userPtr, <span class="dt">const</span> <span class="dt">double</span> n);</code></pre>
<p>A single such callback function can be registered per scene by calling</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetProgressMonitorFunction(RTCScene, RTCProgressMonitorFunc, <span class="dt">void</span>* userPtr);</code></pre>
<p>and deregistered again by calling it with <code>NULL</code> for the callback function. Once registered Embree will invoke the callback function multiple times during hierarchy build operations of the scene, by providing the <code>userPtr</code> pointer that was set at registration time, and a double <code>n</code> in the range <span class="math">[0, 1]</span> estimating the completion amount of the operation. The callback function might get called from multiple threads concurrently.</p>
<p>When returning <code>true</code> from the callback function, Embree will continue the build operation normally. When returning <code>false</code> Embree will cancel the build operation with the RTC_CANCELLED error code. Issuing multiple cancel requests for the same build operation is allowed.</p>
<h2 id="configuring-embree">Configuring Embree</h2>
<p>Some internal parameters can get configured using the <code>rtcSetParameter1i</code> API call.</p>
<p>Currently we support to configure the size of the internal software cache that is used to handle subdivision surfaces by setting the <code>RTC_SOFTWARE_CACHE_SIZE</code> parameter to the desired size of the cache in bytes:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetParameter1i(RTC_SOFTWARE_CACHE_SIZE, bytes);</code></pre>
<p>The software cache cannot get configured while any Embree API call is executed. Best configure the size of the cache only once at application start.</p>
      </div>

      <div id="footer">
        © 2009–2015 Intel Corporation <a href="legal.html">Disclaimer and Legal Information</a>
      </div>
    </div>
  </body>
</html>
